- Granularity in [[abstraction]]
	- Abstraction gives big 4 [[OOP]] Concepts:
		- {{video https://www.youtube.com/watch?v=pTB0EiLXUC8}}
		- Encapsulation
		- Abstraction
		- Inheritence
		- Polymorphism
	- These concepts are essential to communicating effectively
		- As developers
		- As co-workers
	- Abstraction allows segmentation, and vice versa
	- Useful because shit breaks, and when it does, you need to find a way to deal with that gracefully.
	- Segmentation through abstraction is how all of the following work (At different scales):
		- OOP
		- Microservices
		- Data Schemas
		- Programs/Divisions
		- The entire concept of modern security
		- Scrum
		- The Internet:TM:
		- Libraries/Packages
		- ISO/Standards
		- The idea of "suppliers" vs "producers" vs "consumers"
			- Pacta could be "producer"
				- Would be hilarious to be "data middleman"
		- APIs
	- Sometimes it's a good thing (a better version of something comes out)
	- Formalizes the contract
		- can be tested
		- can be diagnosed
		- can be replaced
			- Because it needs to be, or because it's a significant improvment
	- Segmentation in data looks like:
		- Clear definitions for fields
		- Identification of grain
		- Segmentation into schemas
		- Granulation in time
			- Valid from/to
			- Inclusion of time description in grain
		- Basically, designing a DW.
		- Segmentation into schema allows independence in choice of internals
		- Define a "public" and "private" definition to develop against.
			- This may or may not be related to Auth public/private, but can be (psql roles do this well, `foo::bar` vs `foo:::baz` in R does not.)
			- public/private vs stable/unstable
		- In any case, provide a stable product that someone can understand and use effectively.
			- Very often that someone is you
-
- #MyJob is to provide a stable point of access for our clients, while giving the people improving it a space to do so safely.